.. include:: ../_header.rst

The awake event
~~~~~~~~~~~~~~~

We propose using Phaser_ events for implementing the User Components behaviors. However, the events provided in Phaser_ are not enough. When you create a component, all properties are set with the default values. Then, you set the values of each property. However, maybe you want to perform certain initialization routine after all properties are set.

Looking into the Phaser_ events, you can do it in the first scene's update (or similar phase). It means, you can listen once for the UPDATE event, and run the initialization routine. It may works for many cases. But maybe, you want to run this routine just after all properties are set, and before the game start the update loop.

For this reason, the |SceneCompiler|_ generates code for emitting a custom event, the **components-awake** event, just after generates the code that creates the component and set the properties. In Phaser_, every game object is an event emitter, and a component can register a listener to the **components-awake** event:

.. code::

    // code generated by the compiler:

    editorCreate() {
    
        // creates the game object
        const dino = this.add.image(400, 240, "FufuSuperDino");
		
        // creates the PushOnClick component
        const dinoPushOnClick = new PushOnClick(dino);

        // sets the component's properties
        dinoPushOnClick.pushDelay = 500;

        // emit the components-awake event
        dino.emit("components-awake");
    }

When you implement a component, you can register a listener on the **components-awake** event:

.. code::

    class PushOnClick {

        constructor(gameObject) {
            ...
            
            this.gameObject = gameObject;

            gameObject.once("components-awake", () => {

                // here I init the component

                // I register a "pointerdown"
                // event for "animating" the game object
                // with a push effect
                this.gameObject.setInteractive()
                    .on("pointerdown", () => {
                        // animate the object with the push effect
                        this.gameObject.scene.add.tween(...);
                    });
            });
        }
    }

In section `A base class for your components <./user-components-super-class.html>`_), we explain how you can use a common super-class for all the components. It simplifies the listening of Phaser_ events, and it also includes the **components-awake** event. So you can rewrite the previous **PushOnClick** component in this way:

.. code::

    class PushOnClick extends UserComponent {

        constructor(gameObject) {
            super(gameObject);
        }

        awake() {

            // Instead of registering an event listener
            // you can override this method.

            this.gameObject.setInteractive()
                .on("pointerdown", () => {
                    // animate the object with the push effect
                    this.gameObject.scene.add.tween(...);
                });
        }
    }